"""
This module handle the access to the logs store
"""
import logging
import os
from enum import Enum
from typing import Optional
from django.conf import settings

from utils import sanitize_file_path


class WorkingDir(Enum):
    """
    This Enum has the values:
        USER_STORAGE
        PROVIDER_STORAGE

    Both values are being used to identify in
        LogsStorage service the path to be used
    """

    USER_STORAGE = 1
    PROVIDER_STORAGE = 2


logger = logging.getLogger("gateway")


class LogsStorage:
    """
    The main objective of this class is to manage the access to logs generated by a Job.

    Attributes:
        username (str): storage user's username
        working_dir (WorkingDir(Enum)): working directory
        function_title (str): title of the function in case is needed to build the path
        provider_name (str | None): name of the provider in caseis needed to build the path
    """

    FILE_EXTENSION = ".log"
    PATH = "logs"
    ENCODING = "utf-8"

    def __init__(
        self,
        username: str,
        working_dir: WorkingDir,
        function_title: str,
        provider_name: Optional[str],
    ) -> None:
        self.sub_path = None
        self.absolute_path = None
        self.username = username

        if working_dir is WorkingDir.USER_STORAGE:
            self.sub_path = self.__get_user_sub_path(function_title, provider_name)
        elif working_dir is WorkingDir.PROVIDER_STORAGE:
            self.sub_path = self.__get_provider_sub_path(function_title, provider_name)

        self.absolute_path = self.__get_absolute_path(self.sub_path)

    def __get_user_sub_path(
        self, function_title: str, provider_name: Optional[str]
    ) -> str:
        """
        This method returns the sub-path where the logs for the user will
        be stored

        Args:
            function_title (str): in case the function is from a
                provider it will identify the function folder
            provider_name (str | None): in case a provider is provided it will
                identify the folder for the specific function

        Returns:
            str: storage sub-path.
                - In case the function is from a provider that sub-path would
                    be: username/provider_name/function_title/logs
                - In case the function is from a user that path would
                    be: username/logs
        """
        if provider_name is None:
            path = os.path.join(self.username, self.PATH)
        else:
            path = os.path.join(self.username, provider_name, function_title, self.PATH)

        return sanitize_file_path(path)

    def __get_provider_sub_path(self, function_title: str, provider_name: str) -> str:
        """
        This method returns the provider sub-path where the logs for the partner will
        be stored

        Args:
            function_title (str): in case the function is from a provider
                it will identify the function folder
            provider_name (str): in case a provider is provided
                it will identify the folder for the specific function

        Returns:
            str: storage sub-path following the format provider_name/function_title/logs
        """
        path = os.path.join(provider_name, function_title, self.PATH)

        return sanitize_file_path(path)

    def __get_absolute_path(self, sub_path: str) -> str:
        """
        This method returns the absolute path where logs will be stored

        Args:
            sub_path (str): the sub-path that we will use to build
                the absolute path

        Returns:
            str: storage path.
        """
        path = os.path.join(settings.MEDIA_ROOT, sub_path)
        sanitized_path = sanitize_file_path(path)

        # Create directory if it doesn't exist
        if not os.path.exists(sanitized_path):
            os.makedirs(sanitized_path, exist_ok=True)
            logger.debug("Path %s was created.", sanitized_path)

        return sanitized_path

    def _get_log_path(self, job_id: str) -> str:
        """
        Return the path to a log file from the id of a Job

        Args:
            job_id (str): the id for the job to get the log file

        Returns:
            Optional[str]: path to the log file
        """
        return os.path.join(self.absolute_path, f"{job_id}{self.FILE_EXTENSION}")

    def get(self, job_id: str) -> Optional[str]:
        """
        Retrieve a log file for the given job id

        Args:
            job_id (str): the id for the job to get the logs

        Returns:
            Optional[str]: content of the file
        """
        log_path = self._get_log_path(job_id)
        if not os.path.exists(log_path):
            logger.info(
                "Log file for job ID '%s' not found in directory '%s'.",
                job_id,
                log_path,
            )
            return None

        try:
            with open(log_path, "r", encoding=self.ENCODING) as log_file:
                return log_file.read()
        except (UnicodeDecodeError, IOError) as e:
            logger.error(
                "Failed to read log file for job ID '%s': %s",
                job_id,
                str(e),
            )
            return None
